<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
		>
<channel>
	<title>Comments on: Explication de code: des mixins et des décorateurs de méthode pour Django</title>
	<atom:link href="http://sametmax.com/explication-de-code-des-mixins-et-des-decorateurs-de-methode-pour-django/feed/" rel="self" type="application/rss+xml" />
	<link>http://sametmax.com/explication-de-code-des-mixins-et-des-decorateurs-de-methode-pour-django/</link>
	<description>Deux développeurs en vadrouille qui se sortent les doigts du code</description>
	<lastBuildDate>Mon, 02 Dec 2013 10:54:05 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>http://wordpress.org/?v=3.3.1</generator>
	<item>
		<title>By: FoxMaSk</title>
		<link>http://sametmax.com/explication-de-code-des-mixins-et-des-decorateurs-de-methode-pour-django/#comment-1497</link>
		<dc:creator>FoxMaSk</dc:creator>
		<pubDate>Tue, 21 Aug 2012 23:51:37 +0000</pubDate>
		<guid isPermaLink="false">http://sametmax.com/?p=1812#comment-1497</guid>
		<description>Superbe article, limpide,  pour le neophite que je suis. Ya pas à dire, quand on maîtrise son sujet il est facile de mettre en lumière les subtilités comme celles ci. Du coup ça serait cool effectivement d&#039;avoir un crobar du worflow des CBV. Dans le cas d&#039;une page d&#039;un profil utilisateur,  Ça me  permettrait d&#039;éclaircir comment, après avoir surchargé le model User, je gère la form et la view, pour prendre en compte ces nouvelles propriétés lors de la soumission du formulaire.</description>
		<content:encoded><![CDATA[<p>Superbe article, limpide,  pour le neophite que je suis. Ya pas à dire, quand on maîtrise son sujet il est facile de mettre en lumière les subtilités comme celles ci. Du coup ça serait cool effectivement d&#8217;avoir un crobar du worflow des CBV. Dans le cas d&#8217;une page d&#8217;un profil utilisateur,  Ça me  permettrait d&#8217;éclaircir comment, après avoir surchargé le model User, je gère la form et la view, pour prendre en compte ces nouvelles propriétés lors de la soumission du formulaire.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Sam</title>
		<link>http://sametmax.com/explication-de-code-des-mixins-et-des-decorateurs-de-methode-pour-django/#comment-1496</link>
		<dc:creator>Sam</dc:creator>
		<pubDate>Tue, 21 Aug 2012 21:46:54 +0000</pubDate>
		<guid isPermaLink="false">http://sametmax.com/?p=1812#comment-1496</guid>
		<description>@Guillaume: voilà. C&#039;est le but de l&#039;héritage: ne pas avoir à tout réécrire.</description>
		<content:encoded><![CDATA[<p>@Guillaume: voilà. C&#8217;est le but de l&#8217;héritage: ne pas avoir à tout réécrire.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Sveetch</title>
		<link>http://sametmax.com/explication-de-code-des-mixins-et-des-decorateurs-de-methode-pour-django/#comment-1491</link>
		<dc:creator>Sveetch</dc:creator>
		<pubDate>Tue, 21 Aug 2012 19:04:04 +0000</pubDate>
		<guid isPermaLink="false">http://sametmax.com/?p=1812#comment-1491</guid>
		<description>Très bonne explication, très didactique, juste pour mentionner que le code soumis en snippets provient de l&#039;initiative django-braces : https://github.com/brack3t/django-braces</description>
		<content:encoded><![CDATA[<p>Très bonne explication, très didactique, juste pour mentionner que le code soumis en snippets provient de l&#8217;initiative django-braces : <a href="https://github.com/brack3t/django-braces" rel="nofollow">https://github.com/brack3t/django-braces</a></p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guillaume</title>
		<link>http://sametmax.com/explication-de-code-des-mixins-et-des-decorateurs-de-methode-pour-django/#comment-1490</link>
		<dc:creator>Guillaume</dc:creator>
		<pubDate>Tue, 21 Aug 2012 16:23:25 +0000</pubDate>
		<guid isPermaLink="false">http://sametmax.com/?p=1812#comment-1490</guid>
		<description>Je pense avoir pigé, la version &quot;lourde&quot; (avec la batterie de méthodes) du dispatch est dans le parent...</description>
		<content:encoded><![CDATA[<p>Je pense avoir pigé, la version &#8220;lourde&#8221; (avec la batterie de méthodes) du dispatch est dans le parent&#8230;</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Sam</title>
		<link>http://sametmax.com/explication-de-code-des-mixins-et-des-decorateurs-de-methode-pour-django/#comment-1489</link>
		<dc:creator>Sam</dc:creator>
		<pubDate>Tue, 21 Aug 2012 16:10:25 +0000</pubDate>
		<guid isPermaLink="false">http://sametmax.com/?p=1812#comment-1489</guid>
		<description>Là on tombe dans des considérations de POO, cf mon alerte en début d&#039;article.

Quand on fait:

&lt;pre lang=&quot;python&quot;&gt;class MaView(ListView):
    pass&lt;/pre&gt;

MaView n&#039;implémente pas dispatch, donc quand MaView.dispatch sera appelée, ListView.dispatch sera utilisé automatiquement.

Quand on fait:

&lt;pre lang=&quot;python&quot;&gt;class MaView(ListView):
    ...
    @method_decorator(login_required)
    def dispatch(self, *args, **kwargs):
        ...
&lt;/pre&gt;
MaView implémente dispatch. Du coup tout le code du parent (dont nous avons vu l&#039;importance dans le commentaire précédent), n&#039;est pas appelé, et la vue ne peut pas marcher. D&#039;où le super(), qui permet d&#039;appeler à la fin le dispatch du parent:
&lt;pre lang=&quot;python&quot;&gt;
class MaView(ListView):
    ...
    @method_decorator(login_required)
    def dispatch(self, *args, **kwargs):
        return super(ProtectedView, self).dispatch(*args, **kwargs)&lt;/pre&gt;

Dans le cas d&#039;un mixin:

&lt;pre lang=&quot;python&quot;&gt;class MaVue(PermissionsRequiredMixin, ListView):
    required_permissions = (
        &#039;dealer.create_cocaine&#039;,
        &#039;dealer.delete_cocaine&#039;,
    )&lt;/pre&gt;

MaVue n&#039;implémente PAS dispatch. Donc quand on appelle MaVue.dispatch, c&#039;est le PermissionsRequiredMixin.dispatch qui est appelé. Qui heureusement appelle ListView.dispatch ce qui permet à la vue de marcher.</description>
		<content:encoded><![CDATA[<p>Là on tombe dans des considérations de POO, cf mon alerte en début d&#8217;article.</p>
<p>Quand on fait:</p>

<div class="wp_syntax"><div class="code"><pre class="python" style="font-family:monospace;"><span style="color: #ff7700;font-weight:bold;">class</span> MaView<span style="color: black;">&#40;</span>ListView<span style="color: black;">&#41;</span>:
    <span style="color: #ff7700;font-weight:bold;">pass</span></pre></div></div>

<p>MaView n&#8217;implémente pas dispatch, donc quand MaView.dispatch sera appelée, ListView.dispatch sera utilisé automatiquement.</p>
<p>Quand on fait:</p>

<div class="wp_syntax"><div class="code"><pre class="python" style="font-family:monospace;"><span style="color: #ff7700;font-weight:bold;">class</span> MaView<span style="color: black;">&#40;</span>ListView<span style="color: black;">&#41;</span>:
    ...
    @method_decorator<span style="color: black;">&#40;</span>login_required<span style="color: black;">&#41;</span>
    <span style="color: #ff7700;font-weight:bold;">def</span> dispatch<span style="color: black;">&#40;</span><span style="color: #008000;">self</span>, <span style="color: #66cc66;">*</span>args, <span style="color: #66cc66;">**</span>kwargs<span style="color: black;">&#41;</span>:
        ...</pre></div></div>

<p>MaView implémente dispatch. Du coup tout le code du parent (dont nous avons vu l&#8217;importance dans le commentaire précédent), n&#8217;est pas appelé, et la vue ne peut pas marcher. D&#8217;où le super(), qui permet d&#8217;appeler à la fin le dispatch du parent:</p>

<div class="wp_syntax"><div class="code"><pre class="python" style="font-family:monospace;"><span style="color: #ff7700;font-weight:bold;">class</span> MaView<span style="color: black;">&#40;</span>ListView<span style="color: black;">&#41;</span>:
    ...
    @method_decorator<span style="color: black;">&#40;</span>login_required<span style="color: black;">&#41;</span>
    <span style="color: #ff7700;font-weight:bold;">def</span> dispatch<span style="color: black;">&#40;</span><span style="color: #008000;">self</span>, <span style="color: #66cc66;">*</span>args, <span style="color: #66cc66;">**</span>kwargs<span style="color: black;">&#41;</span>:
        <span style="color: #ff7700;font-weight:bold;">return</span> <span style="color: #008000;">super</span><span style="color: black;">&#40;</span>ProtectedView, <span style="color: #008000;">self</span><span style="color: black;">&#41;</span>.<span style="color: black;">dispatch</span><span style="color: black;">&#40;</span><span style="color: #66cc66;">*</span>args, <span style="color: #66cc66;">**</span>kwargs<span style="color: black;">&#41;</span></pre></div></div>

<p>Dans le cas d&#8217;un mixin:</p>

<div class="wp_syntax"><div class="code"><pre class="python" style="font-family:monospace;"><span style="color: #ff7700;font-weight:bold;">class</span> MaVue<span style="color: black;">&#40;</span>PermissionsRequiredMixin, ListView<span style="color: black;">&#41;</span>:
    required_permissions = <span style="color: black;">&#40;</span>
        <span style="color: #483d8b;">'dealer.create_cocaine'</span>,
        <span style="color: #483d8b;">'dealer.delete_cocaine'</span>,
    <span style="color: black;">&#41;</span></pre></div></div>

<p>MaVue n&#8217;implémente PAS dispatch. Donc quand on appelle MaVue.dispatch, c&#8217;est le PermissionsRequiredMixin.dispatch qui est appelé. Qui heureusement appelle ListView.dispatch ce qui permet à la vue de marcher.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guillaume</title>
		<link>http://sametmax.com/explication-de-code-des-mixins-et-des-decorateurs-de-methode-pour-django/#comment-1488</link>
		<dc:creator>Guillaume</dc:creator>
		<pubDate>Tue, 21 Aug 2012 15:43:32 +0000</pubDate>
		<guid isPermaLink="false">http://sametmax.com/?p=1812#comment-1488</guid>
		<description>Excellent, mais...! Pourquoi le dispatch du parent? La classe fille implémente aussi dispatch(). Je ne saisis pas la subtilité. Je vous ferai une statue quand j&#039;aurai bien tout compris!</description>
		<content:encoded><![CDATA[<p>Excellent, mais&#8230;! Pourquoi le dispatch du parent? La classe fille implémente aussi dispatch(). Je ne saisis pas la subtilité. Je vous ferai une statue quand j&#8217;aurai bien tout compris!</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Sam</title>
		<link>http://sametmax.com/explication-de-code-des-mixins-et-des-decorateurs-de-methode-pour-django/#comment-1487</link>
		<dc:creator>Sam</dc:creator>
		<pubDate>Tue, 21 Aug 2012 15:28:07 +0000</pubDate>
		<guid isPermaLink="false">http://sametmax.com/?p=1812#comment-1487</guid>
		<description>Voilà le code de la méthode dispatch:

&lt;pre lang=&quot;python&quot;&gt;    def dispatch(self, request, *args, **kwargs):
        # Try to dispatch to the right method; if a method doesn&#039;t exist,
        # defer to the error handler. Also defer to the error handler if the
        # request method isn&#039;t on the approved list.
        if request.method.lower() in self.http_method_names:
            handler = getattr(self, request.method.lower(), self.http_method_not_allowed)
        else:
            handler = self.http_method_not_allowed
        self.request = request
        self.args = args
        self.kwargs = kwargs
        return handler(request, *args, **kwargs)&lt;/pre&gt;

Le rôle de dispatch() est donc multiple:

- appeler la méthode post() ou get() (ou head() ou option(), etc. car tous les verbes HTTP sont disponibles) de la vue selon le type de requête;
- si le verbe HTTP n&#039;est pas un verbe connu, appeler la méthode http_method_not_allowed();
- si le verbe HTTP fait parti des methodes interdites pour cette vue, appeler http_method_not_allowed();
- ajouter à l&#039;instance courante de la vue les attributs request, args et kwargs.

On appelle donc TOUJOURS la méthode dispatch du parent, car toutes ces étapes sont nécessaires, pour toute les vues.

Typiquement, dans le cas d&#039;une vue de formulaire, on aura toujours du GET (pour l&#039;affichage du formulaire à vide) et du POST (pour l&#039;envoie des données du formulaire), donc c&#039;est toujours utile dans ce cas.

C&#039;est d&#039;ailleurs exactement ce que fait la vue générique ProcessFormView:

https://docs.djangoproject.com/en/1.4/ref/class-based-views/#processformview

Mais même dans le cas hypothétique d&#039;une vue qui n&#039;accepte que POST (ce qui est dommage, HEAD étant un verbe HTTP très utilisé par les navigateurs WEB pour la gestion du cache), on souhaite quand même garder dispatch()car elle a un rôle de sécurité: elle appelle http_method_not_allowed pour tous les autres verbes HTTP. Sans compter que sans self.request et self.kwargs, on ne peut pas faire grand chose dans une CBV.</description>
		<content:encoded><![CDATA[<p>Voilà le code de la méthode dispatch:</p>

<div class="wp_syntax"><div class="code"><pre class="python" style="font-family:monospace;">    <span style="color: #ff7700;font-weight:bold;">def</span> dispatch<span style="color: black;">&#40;</span><span style="color: #008000;">self</span>, request, <span style="color: #66cc66;">*</span>args, <span style="color: #66cc66;">**</span>kwargs<span style="color: black;">&#41;</span>:
        <span style="color: #808080; font-style: italic;"># Try to dispatch to the right method; if a method doesn't exist,</span>
        <span style="color: #808080; font-style: italic;"># defer to the error handler. Also defer to the error handler if the</span>
        <span style="color: #808080; font-style: italic;"># request method isn't on the approved list.</span>
        <span style="color: #ff7700;font-weight:bold;">if</span> request.<span style="color: black;">method</span>.<span style="color: black;">lower</span><span style="color: black;">&#40;</span><span style="color: black;">&#41;</span> <span style="color: #ff7700;font-weight:bold;">in</span> <span style="color: #008000;">self</span>.<span style="color: black;">http_method_names</span>:
            handler = <span style="color: #008000;">getattr</span><span style="color: black;">&#40;</span><span style="color: #008000;">self</span>, request.<span style="color: black;">method</span>.<span style="color: black;">lower</span><span style="color: black;">&#40;</span><span style="color: black;">&#41;</span>, <span style="color: #008000;">self</span>.<span style="color: black;">http_method_not_allowed</span><span style="color: black;">&#41;</span>
        <span style="color: #ff7700;font-weight:bold;">else</span>:
            handler = <span style="color: #008000;">self</span>.<span style="color: black;">http_method_not_allowed</span>
        <span style="color: #008000;">self</span>.<span style="color: black;">request</span> = request
        <span style="color: #008000;">self</span>.<span style="color: black;">args</span> = args
        <span style="color: #008000;">self</span>.<span style="color: black;">kwargs</span> = kwargs
        <span style="color: #ff7700;font-weight:bold;">return</span> handler<span style="color: black;">&#40;</span>request, <span style="color: #66cc66;">*</span>args, <span style="color: #66cc66;">**</span>kwargs<span style="color: black;">&#41;</span></pre></div></div>

<p>Le rôle de dispatch() est donc multiple:</p>
<p>- appeler la méthode post() ou get() (ou head() ou option(), etc. car tous les verbes HTTP sont disponibles) de la vue selon le type de requête;<br />
- si le verbe HTTP n&#8217;est pas un verbe connu, appeler la méthode http_method_not_allowed();<br />
- si le verbe HTTP fait parti des methodes interdites pour cette vue, appeler http_method_not_allowed();<br />
- ajouter à l&#8217;instance courante de la vue les attributs request, args et kwargs.</p>
<p>On appelle donc TOUJOURS la méthode dispatch du parent, car toutes ces étapes sont nécessaires, pour toute les vues.</p>
<p>Typiquement, dans le cas d&#8217;une vue de formulaire, on aura toujours du GET (pour l&#8217;affichage du formulaire à vide) et du POST (pour l&#8217;envoie des données du formulaire), donc c&#8217;est toujours utile dans ce cas.</p>
<p>C&#8217;est d&#8217;ailleurs exactement ce que fait la vue générique ProcessFormView:</p>
<p><a href="https://docs.djangoproject.com/en/1.4/ref/class-based-views/#processformview" rel="nofollow">https://docs.djangoproject.com/en/1.4/ref/class-based-views/#processformview</a></p>
<p>Mais même dans le cas hypothétique d&#8217;une vue qui n&#8217;accepte que POST (ce qui est dommage, HEAD étant un verbe HTTP très utilisé par les navigateurs WEB pour la gestion du cache), on souhaite quand même garder dispatch()car elle a un rôle de sécurité: elle appelle http_method_not_allowed pour tous les autres verbes HTTP. Sans compter que sans self.request et self.kwargs, on ne peut pas faire grand chose dans une CBV.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Guillaume</title>
		<link>http://sametmax.com/explication-de-code-des-mixins-et-des-decorateurs-de-methode-pour-django/#comment-1486</link>
		<dc:creator>Guillaume</dc:creator>
		<pubDate>Tue, 21 Aug 2012 15:12:57 +0000</pubDate>
		<guid isPermaLink="false">http://sametmax.com/?p=1812#comment-1486</guid>
		<description>Brillant l&#039;article! J&#039;ai suivi la mécanique de la démonstration globalement mais je me heurte
à des questions métaphysiques!
La fonction dispatch, pas de souci avec ses arguments extraits des URLs.
Par contre un &quot;zoom&quot; sur sa finalité s&#039;impose.
Le dispatch, c&#039;est l&#039;aiguillage, le 2 en 1 du get et du post? True?
Petite question :
une soumission par un formulaire, je vais avoir du post. Est ce que le dispatch de la vue
pourrait être géré une fonction post? je suppose que oui.
Mais alors quelle est la finalité d&#039;utiliser la fonction dispatch de la classe parent de la vue?
Je crois que vos explications seront les bienvenue!</description>
		<content:encoded><![CDATA[<p>Brillant l&#8217;article! J&#8217;ai suivi la mécanique de la démonstration globalement mais je me heurte<br />
à des questions métaphysiques!<br />
La fonction dispatch, pas de souci avec ses arguments extraits des URLs.<br />
Par contre un &#8220;zoom&#8221; sur sa finalité s&#8217;impose.<br />
Le dispatch, c&#8217;est l&#8217;aiguillage, le 2 en 1 du get et du post? True?<br />
Petite question :<br />
une soumission par un formulaire, je vais avoir du post. Est ce que le dispatch de la vue<br />
pourrait être géré une fonction post? je suppose que oui.<br />
Mais alors quelle est la finalité d&#8217;utiliser la fonction dispatch de la classe parent de la vue?<br />
Je crois que vos explications seront les bienvenue!</p>
]]></content:encoded>
	</item>
</channel>
</rss>
