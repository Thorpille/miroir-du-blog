<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>Comments on: La mort du tuto angular</title>
	<atom:link href="http://sametmax.com/la-mort-du-tuto-angular/feed/" rel="self" type="application/rss+xml" />
	<link>http://sametmax.com/la-mort-du-tuto-angular/</link>
	<description>Du code, du cul</description>
	<lastBuildDate>Sat, 07 Nov 2015 11:08:18 +0000</lastBuildDate>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>http://wordpress.org/?v=4.1</generator>
	<item>
		<title>By: Sam</title>
		<link>http://sametmax.com/la-mort-du-tuto-angular/#comment-162486</link>
		<dc:creator><![CDATA[Sam]]></dc:creator>
		<pubDate>Tue, 23 Jun 2015 17:00:36 +0000</pubDate>
		<guid isPermaLink="false">http://sametmax.com/?p=16389#comment-162486</guid>
		<description><![CDATA[&lt;p&gt;Non, mais ça veut dire pour faire des la mise à jour temps réel avec des modèles côté clients qui font automatiquement des modifications sur le serveur de manière transparente.&lt;/p&gt;

&lt;p&gt;On pourrait bien entendu, utiliser brython pour donner l&#039;illusion qu&#039;on utilise du python par tout, mais je suis pas fan des pre-processeurs.&lt;/p&gt;
]]></description>
		<content:encoded><![CDATA[<p>Non, mais ça veut dire pour faire des la mise à jour temps réel avec des modèles côté clients qui font automatiquement des modifications sur le serveur de manière transparente.</p>
<p>On pourrait bien entendu, utiliser brython pour donner l&#8217;illusion qu&#8217;on utilise du python par tout, mais je suis pas fan des pre-processeurs.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: walt</title>
		<link>http://sametmax.com/la-mort-du-tuto-angular/#comment-162485</link>
		<dc:creator><![CDATA[walt]]></dc:creator>
		<pubDate>Tue, 23 Jun 2015 16:45:35 +0000</pubDate>
		<guid isPermaLink="false">http://sametmax.com/?p=16389#comment-162485</guid>
		<description><![CDATA[Est-ce que ça signifie &quot;pouvoir faire un site web (front+back) entièrement en Python ?&quot; Comment c&#039;est possible ?
]]></description>
		<content:encoded><![CDATA[<p>Est-ce que ça signifie &#8220;pouvoir faire un site web (front+back) entièrement en Python ?&#8221; Comment c&#8217;est possible ?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Sam</title>
		<link>http://sametmax.com/la-mort-du-tuto-angular/#comment-162278</link>
		<dc:creator><![CDATA[Sam]]></dc:creator>
		<pubDate>Thu, 18 Jun 2015 18:45:16 +0000</pubDate>
		<guid isPermaLink="false">http://sametmax.com/?p=16389#comment-162278</guid>
		<description><![CDATA[&lt;p&gt;Si, on peut carrément avoir un meteor.js en python, justement :)&lt;/p&gt;
]]></description>
		<content:encoded><![CDATA[<p>Si, on peut carrément avoir un meteor.js en python, justement :)</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: walt</title>
		<link>http://sametmax.com/la-mort-du-tuto-angular/#comment-162266</link>
		<dc:creator><![CDATA[walt]]></dc:creator>
		<pubDate>Thu, 18 Jun 2015 15:37:15 +0000</pubDate>
		<guid isPermaLink="false">http://sametmax.com/?p=16389#comment-162266</guid>
		<description><![CDATA[En effet ça fait un paquet de choses sympas ! Tu commences quand ? (ah non pardon tu as déjà une plate-forme de blog en cours au temps pour moi ^^).

Plus sérieusement, certes l&#039;intégration directe dans le framework est un plus mais je trouve pas que ce soit essentiel dans tous les cas. C&#039;est pas la mort de faire un pip install + de rajouter une app dans Django. Là je parle pour certains de tes exemples, pas tous évidemment. Le plus chiant finalement je trouve c&#039;est de devoir parcourir les github pour trouver les bons packages qui vont bien.

Sinon, j&#039;arrive toujours pas à digérer le fait qu&#039;on aura sûrement jamais un équivalent de meteor.js en python...

Au moins avant on n&#039;avait que php et mysql et personne n&#039;utilisait le JS&lt;/vieux con&gt;
]]></description>
		<content:encoded><![CDATA[<p>En effet ça fait un paquet de choses sympas ! Tu commences quand ? (ah non pardon tu as déjà une plate-forme de blog en cours au temps pour moi ^^).</p>
<p>Plus sérieusement, certes l&#8217;intégration directe dans le framework est un plus mais je trouve pas que ce soit essentiel dans tous les cas. C&#8217;est pas la mort de faire un pip install + de rajouter une app dans Django. Là je parle pour certains de tes exemples, pas tous évidemment. Le plus chiant finalement je trouve c&#8217;est de devoir parcourir les github pour trouver les bons packages qui vont bien.</p>
<p>Sinon, j&#8217;arrive toujours pas à digérer le fait qu&#8217;on aura sûrement jamais un équivalent de meteor.js en python&#8230;</p>
<p>Au moins avant on n&#8217;avait que php et mysql et personne n&#8217;utilisait le JS&lt;/vieux con&gt;</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Sam</title>
		<link>http://sametmax.com/la-mort-du-tuto-angular/#comment-162261</link>
		<dc:creator><![CDATA[Sam]]></dc:creator>
		<pubDate>Thu, 18 Jun 2015 12:02:01 +0000</pubDate>
		<guid isPermaLink="false">http://sametmax.com/?p=16389#comment-162261</guid>
		<description><![CDATA[&lt;p&gt;Ca  me fait penser à ça : https://www.destroyallsoftware.com/talks/the-birth-and-death-of-javascript&lt;/p&gt;

&lt;p&gt;D&#039;un coté, le bytecode devrait permettre l&#039;amélioration de la portabilité, d&#039;un autre côté, ça veut dire quand même qu&#039;on va se faire chier à compiler le langage, et faire les sources maps qui vont avec, et les mappers, et donc avec le setup qui va avec. Et bien entendu il faudra envoyer tout truc qui n&#039;est pas dans la lib standard, donc encore des trucs à uploader. Et il y aura des fuites d&#039;abstractions qui vont nous bouffer les couilles.&lt;/p&gt;

&lt;p&gt;Encore une fois ça va dans le bon sens, mais comme javascript n&#039;est pas de l&#039;assembleur, et qu&#039;au final c&#039;est un bidouillage pour faire au mieux avec ce qu&#039;on a, ça va avoir un gout bizarre à la fin.&lt;/p&gt;

&lt;p&gt;Mais bon, c&#039;est fantastique qu&#039;on ait des génies qui essayent de mettre au point des moyens de contournement décents. Et qui sait, peut être que dans 10 ans les gens coderont tous comme ça, et quand on dira que c&#039;est une couche de merde sur une tartine de pisse (&lt;strong&gt;un langage interprété sur un pseudo bytecode créé en langage interprété tournant au dessus d&#039;une VM dans une sandbox de navigateur et qui fait ses imports via des appels TCP/IP&lt;/strong&gt;), ils auront la même réaction que quand on discute avec les vieux codeurs fortrans qui nous sortent que Python est c&#039;est pas optimisé :)&lt;/p&gt;

&lt;p&gt;Pour les frameworks nouvelles générations, ça s&#039;inscrit tout simplement dans la lignée de commulations de technos qui arrivent à maturités en Python. On a maintenant tout un tas d&#039;outils isoles :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;gestionnaires de cache&lt;/li&gt;
&lt;li&gt;vm tracantes&lt;/li&gt;
&lt;li&gt;lib asynchrones&lt;/li&gt;
&lt;li&gt;file systèmes watchers&lt;/li&gt;
&lt;li&gt;sérialiseurs&lt;/li&gt;
&lt;li&gt;RPC  &lt;/li&gt;
&lt;li&gt;PUB/SUB&lt;/li&gt;
&lt;li&gt;gestionnaires de file&lt;/li&gt;
&lt;li&gt;scheduleurs&lt;/li&gt;
&lt;li&gt;routeurs&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ces trucs sont au point. D&#039;un autre côté on a la 3.5 qui va proposer async/await et les types hints, qui vont attirer pas mal de monde, de nouveaux types codeurs, des nouveaux profiles, et entériner des pratiques naissantes dans le monde de Python.&lt;/p&gt;

&lt;p&gt;Je gage donc certains vont vouloir faire mieux que NodeJS / Tornado et utiliser ces éléments pour faires des choses un peu mignones.&lt;/p&gt;

&lt;p&gt;Déjà il y a plein d&#039;outils Node sur lesquels on est en retard et qu&#039;il faut copier :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;transpilers automatiques&lt;/li&gt;
&lt;li&gt;auto reloaders de pages&lt;/li&gt;
&lt;li&gt;routing websocket aussi facile que le routing HTTP&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;En Python on a tout ça, mais ça demande du travail d&#039;intégration.&lt;/p&gt;

&lt;p&gt;Ensuite, y a du travail à faire pour rendre certains outils plus friendly avec la prog asynchrones :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;les ORM&lt;/li&gt;
&lt;li&gt;les templates&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Enfin, y a des systèmes qu&#039;on utilise tous les jours en prog web qui n&#039;ont aucune raison de manquer dans un framework digne de ce nom :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;tasks queue&lt;/li&gt;
&lt;li&gt;bdd clé / valeur embarquée&lt;/li&gt;
&lt;li&gt;settings partagés entre tous les clients et mis à jour en temps réel&lt;/li&gt;
&lt;li&gt;multi-processing à la carte&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ainsi, on peut imaginer piocher dans ces trucs là, coller le tout au cul de crossbar.io, mélanger avec du async/await, et obtenir un framework web avec la syntax de flask, mais qui permet des trucs cool du genre :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;envoyer une tache de longue durée dans une file, et récupérer le pourcentage de progression en une ligne sur une page web&lt;/li&gt;
&lt;li&gt;choisir quelles routes vont taper dans quel processus et donc répartir la charge par CPU&lt;/li&gt;
&lt;li&gt;reloader un de ses micro-services à chaud&lt;/li&gt;
&lt;li&gt;injecter du code JS à distance dans un navigateurs pour les tests&lt;/li&gt;
&lt;li&gt;avoir un console log sur un navigateur mobile qui print sur ta console de l&#039;ordi&lt;/li&gt;
&lt;li&gt;avoir tous tes fichiers less, coffeescript, hype.mabite, etc qui sont pré-processé dans un tab du navigateur via web worker en rpc. Pas besoin d&#039;installer nodejs sur son serveur.&lt;/li&gt;
&lt;li&gt;des modèles JS qui font du RPC automatiquement pour faire du CRUD load balancé.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Tout ça est déjà possible (et certaines choses existent en Python, ou ailleurs), mais on peut faire des frameworks qui ont tout ça intégré. Et je pense que les derniers ajouts à Python vont catalyser tout ça.&lt;/p&gt;
]]></description>
		<content:encoded><![CDATA[<p>Ca  me fait penser à ça : <a href="https://www.destroyallsoftware.com/talks/the-birth-and-death-of-javascript" rel="nofollow">https://www.destroyallsoftware.com/talks/the-birth-and-death-of-javascript</a></p>
<p>D&#8217;un coté, le bytecode devrait permettre l&#8217;amélioration de la portabilité, d&#8217;un autre côté, ça veut dire quand même qu&#8217;on va se faire chier à compiler le langage, et faire les sources maps qui vont avec, et les mappers, et donc avec le setup qui va avec. Et bien entendu il faudra envoyer tout truc qui n&#8217;est pas dans la lib standard, donc encore des trucs à uploader. Et il y aura des fuites d&#8217;abstractions qui vont nous bouffer les couilles.</p>
<p>Encore une fois ça va dans le bon sens, mais comme javascript n&#8217;est pas de l&#8217;assembleur, et qu&#8217;au final c&#8217;est un bidouillage pour faire au mieux avec ce qu&#8217;on a, ça va avoir un gout bizarre à la fin.</p>
<p>Mais bon, c&#8217;est fantastique qu&#8217;on ait des génies qui essayent de mettre au point des moyens de contournement décents. Et qui sait, peut être que dans 10 ans les gens coderont tous comme ça, et quand on dira que c&#8217;est une couche de merde sur une tartine de pisse (<strong>un langage interprété sur un pseudo bytecode créé en langage interprété tournant au dessus d&#8217;une VM dans une sandbox de navigateur et qui fait ses imports via des appels TCP/IP</strong>), ils auront la même réaction que quand on discute avec les vieux codeurs fortrans qui nous sortent que Python est c&#8217;est pas optimisé :)</p>
<p>Pour les frameworks nouvelles générations, ça s&#8217;inscrit tout simplement dans la lignée de commulations de technos qui arrivent à maturités en Python. On a maintenant tout un tas d&#8217;outils isoles :</p>
<ul>
<li>gestionnaires de cache</li>
<li>vm tracantes</li>
<li>lib asynchrones</li>
<li>file systèmes watchers</li>
<li>sérialiseurs</li>
<li>RPC  </li>
<li>PUB/SUB</li>
<li>gestionnaires de file</li>
<li>scheduleurs</li>
<li>routeurs</li>
</ul>
<p>Ces trucs sont au point. D&#8217;un autre côté on a la 3.5 qui va proposer async/await et les types hints, qui vont attirer pas mal de monde, de nouveaux types codeurs, des nouveaux profiles, et entériner des pratiques naissantes dans le monde de Python.</p>
<p>Je gage donc certains vont vouloir faire mieux que NodeJS / Tornado et utiliser ces éléments pour faires des choses un peu mignones.</p>
<p>Déjà il y a plein d&#8217;outils Node sur lesquels on est en retard et qu&#8217;il faut copier :</p>
<ul>
<li>transpilers automatiques</li>
<li>auto reloaders de pages</li>
<li>routing websocket aussi facile que le routing HTTP</li>
</ul>
<p>En Python on a tout ça, mais ça demande du travail d&#8217;intégration.</p>
<p>Ensuite, y a du travail à faire pour rendre certains outils plus friendly avec la prog asynchrones :</p>
<ul>
<li>les ORM</li>
<li>les templates</li>
</ul>
<p>Enfin, y a des systèmes qu&#8217;on utilise tous les jours en prog web qui n&#8217;ont aucune raison de manquer dans un framework digne de ce nom :</p>
<ul>
<li>tasks queue</li>
<li>bdd clé / valeur embarquée</li>
<li>settings partagés entre tous les clients et mis à jour en temps réel</li>
<li>multi-processing à la carte</li>
</ul>
<p>Ainsi, on peut imaginer piocher dans ces trucs là, coller le tout au cul de crossbar.io, mélanger avec du async/await, et obtenir un framework web avec la syntax de flask, mais qui permet des trucs cool du genre :</p>
<ul>
<li>envoyer une tache de longue durée dans une file, et récupérer le pourcentage de progression en une ligne sur une page web</li>
<li>choisir quelles routes vont taper dans quel processus et donc répartir la charge par CPU</li>
<li>reloader un de ses micro-services à chaud</li>
<li>injecter du code JS à distance dans un navigateurs pour les tests</li>
<li>avoir un console log sur un navigateur mobile qui print sur ta console de l&#8217;ordi</li>
<li>avoir tous tes fichiers less, coffeescript, hype.mabite, etc qui sont pré-processé dans un tab du navigateur via web worker en rpc. Pas besoin d&#8217;installer nodejs sur son serveur.</li>
<li>des modèles JS qui font du RPC automatiquement pour faire du CRUD load balancé.</li>
</ul>
<p>Tout ça est déjà possible (et certaines choses existent en Python, ou ailleurs), mais on peut faire des frameworks qui ont tout ça intégré. Et je pense que les derniers ajouts à Python vont catalyser tout ça.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: walt</title>
		<link>http://sametmax.com/la-mort-du-tuto-angular/#comment-162259</link>
		<dc:creator><![CDATA[walt]]></dc:creator>
		<pubDate>Thu, 18 Jun 2015 10:53:39 +0000</pubDate>
		<guid isPermaLink="false">http://sametmax.com/?p=16389#comment-162259</guid>
		<description><![CDATA[Sur le thème des améliorations du JS : http://pro.clubic.com/creation-de-site-web/langage-programmation/html-5/actualite-770804-webassembly-google-microsoft-mozilla-transforme-javascript-binaire.html

Sam, tu peux en dire plus sur les frameworks nouvelles génération ? C&#039;est mal de mettre l&#039;eau à la bouche comme ça et de partir ! ^^
]]></description>
		<content:encoded><![CDATA[<p>Sur le thème des améliorations du JS : <a href="http://pro.clubic.com/creation-de-site-web/langage-programmation/html-5/actualite-770804-webassembly-google-microsoft-mozilla-transforme-javascript-binaire.html" rel="nofollow">http://pro.clubic.com/creation-de-site-web/langage-programmation/html-5/actualite-770804-webassembly-google-microsoft-mozilla-transforme-javascript-binaire.html</a></p>
<p>Sam, tu peux en dire plus sur les frameworks nouvelles génération ? C&#8217;est mal de mettre l&#8217;eau à la bouche comme ça et de partir ! ^^</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Sam</title>
		<link>http://sametmax.com/la-mort-du-tuto-angular/#comment-162249</link>
		<dc:creator><![CDATA[Sam]]></dc:creator>
		<pubDate>Wed, 17 Jun 2015 20:04:33 +0000</pubDate>
		<guid isPermaLink="false">http://sametmax.com/?p=16389#comment-162249</guid>
		<description><![CDATA[&lt;p&gt;Il y a deux bons points :&lt;/p&gt;

&lt;p&gt;Le JS s&#039;améliore, et quand on pourra utiliser ES7 sur le browser on commencera à être un peu plus chez mémé. Ca sera  pas parfait, mais ça sera vivable.&lt;/p&gt;

&lt;p&gt;Ensuite, le Python s&#039;améliore. La 3.5 risque d&#039;amener la naissance de frameworks web Python nouvelles générations qui devraient nous faciliter bien la vie.&lt;/p&gt;
]]></description>
		<content:encoded><![CDATA[<p>Il y a deux bons points :</p>
<p>Le JS s&#8217;améliore, et quand on pourra utiliser ES7 sur le browser on commencera à être un peu plus chez mémé. Ca sera  pas parfait, mais ça sera vivable.</p>
<p>Ensuite, le Python s&#8217;améliore. La 3.5 risque d&#8217;amener la naissance de frameworks web Python nouvelles générations qui devraient nous faciliter bien la vie.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: buffalo974</title>
		<link>http://sametmax.com/la-mort-du-tuto-angular/#comment-162246</link>
		<dc:creator><![CDATA[buffalo974]]></dc:creator>
		<pubDate>Wed, 17 Jun 2015 17:02:55 +0000</pubDate>
		<guid isPermaLink="false">http://sametmax.com/?p=16389#comment-162246</guid>
		<description><![CDATA[Y&#039;a un peu d&#039; espoir pour le futur ? dans quelle direction ?
]]></description>
		<content:encoded><![CDATA[<p>Y&#8217;a un peu d&#8217; espoir pour le futur ? dans quelle direction ?</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Sam</title>
		<link>http://sametmax.com/la-mort-du-tuto-angular/#comment-162202</link>
		<dc:creator><![CDATA[Sam]]></dc:creator>
		<pubDate>Wed, 17 Jun 2015 05:33:57 +0000</pubDate>
		<guid isPermaLink="false">http://sametmax.com/?p=16389#comment-162202</guid>
		<description><![CDATA[&lt;p&gt;Sauf que Javascript n&#039;est PAS un assembleur :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;il n&#039;a rien de bas niveau. En fait, tout est de haut niveau, mais les instructions sont réduites au minimum.&lt;/li&gt;
&lt;li&gt;pour implémenter tout un tas de trucs dessus il faut donc réimplémenter des trucs de bas niveau avec des outils haut niveau. Le truc n&#039;a pas de division entière par exemple, donc tu prends ton float, et tu le round...&lt;/li&gt;
&lt;li&gt;mais toute réimplémentation passe par du code qui passe par le réseau. Tu ne peux pas envoyer une VM Python de 15 pour ta page web, c&#039;est pas raisonnable.&lt;/li&gt;
&lt;li&gt;l&#039;assembleur est optimisé pour les performances ET la faible consommation de ressources. Donc tu peux implémenter des trucs dessus plus haut niveau et t&#039;assoir sur l&#039;overhead. Pour JS, tu as les performances AU PRIX de la consommation de ressources, particulièrement de mémoire vive. Donc si tu utilise une surcouche, tu rajoutes encore de l&#039;overhead.&lt;/li&gt;
&lt;li&gt;JS assume certains paradigme et en exclus d&#039;autres. Le typage est zarb, le code est zarb, l&#039;event loop est implicite... Donc si tu veux implémenter autre chose, tu ne peux pas sortir de ce paradigme, tu dois créer une API qui le masque. En plus d&#039;être dégueulasse, c&#039;est peu performant et il y a toujours des fuites du niveau d&#039;abstraction.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Alors oui, on peut utiliser JS comme on utilise un assembleur, mais ce n&#039;est pas un bon outil pour ça. C&#039;est juste, encore une fois, le seul outil qu&#039;on ait.&lt;/p&gt;

&lt;p&gt;JS n&#039;est bon à rien, et en rien. Il est mal foutu, c&#039;est un brouillon qu&#039;on se traine.&lt;/p&gt;

&lt;p&gt;Certes, des gens brillant font des choses brillantes avec, performantes, utiles, fantastique.&lt;/p&gt;

&lt;p&gt;Mais c&#039;est MALGRE le language, pas GRACE au langage.&lt;/p&gt;

&lt;p&gt;Tout autre langage ferait mieux. Malheureusement on a que celui là dans le navigateur.&lt;/p&gt;

&lt;p&gt;Et comme on a que celui-là et que le Web est tout, on a investi des ressources incroyables dans le JS pour pallier sa nature déficiente. Si tu investis la moitié de ces ressources dans n&#039;importe quel techo, tu aurais un truc extra-ordinnaire :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;tu prends la V8 de google et tu l&#039;applique à un autre langage ? Boom ! Perfs de ouf. 10X celles du JS actuel.&lt;/li&gt;
&lt;li&gt;tu mets les commités d&#039;amélioration ES6 et ES7 sur un autre langage ? Boom. Features de ouf (JS n&#039;a pas encore rattrapé son retard malgré ça).&lt;/li&gt;
&lt;li&gt;tu transferts la communauté des devs web sur un autre langage ? Boom, doc et libs incroyable. (Quand on voit le nombre de personnes là dessus, on se dit que ce potentiel est tellement gaché, tant les tutos JS sont souvent merdiques)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Toutes les qualités de l&#039;environnement JS sont uniquement liées au portail captif qu&#039;est le navigateur, qui a forcé tout ce petit monde à payer la taxe JS. Rien à avoir avec le langage, qui est mal foutu, un verru dans le monde de la programmation.&lt;/p&gt;
]]></description>
		<content:encoded><![CDATA[<p>Sauf que Javascript n&#8217;est PAS un assembleur :</p>
<ul>
<li>il n&#8217;a rien de bas niveau. En fait, tout est de haut niveau, mais les instructions sont réduites au minimum.</li>
<li>pour implémenter tout un tas de trucs dessus il faut donc réimplémenter des trucs de bas niveau avec des outils haut niveau. Le truc n&#8217;a pas de division entière par exemple, donc tu prends ton float, et tu le round&#8230;</li>
<li>mais toute réimplémentation passe par du code qui passe par le réseau. Tu ne peux pas envoyer une VM Python de 15 pour ta page web, c&#8217;est pas raisonnable.</li>
<li>l&#8217;assembleur est optimisé pour les performances ET la faible consommation de ressources. Donc tu peux implémenter des trucs dessus plus haut niveau et t&#8217;assoir sur l&#8217;overhead. Pour JS, tu as les performances AU PRIX de la consommation de ressources, particulièrement de mémoire vive. Donc si tu utilise une surcouche, tu rajoutes encore de l&#8217;overhead.</li>
<li>JS assume certains paradigme et en exclus d&#8217;autres. Le typage est zarb, le code est zarb, l&#8217;event loop est implicite&#8230; Donc si tu veux implémenter autre chose, tu ne peux pas sortir de ce paradigme, tu dois créer une API qui le masque. En plus d&#8217;être dégueulasse, c&#8217;est peu performant et il y a toujours des fuites du niveau d&#8217;abstraction.</li>
</ul>
<p>Alors oui, on peut utiliser JS comme on utilise un assembleur, mais ce n&#8217;est pas un bon outil pour ça. C&#8217;est juste, encore une fois, le seul outil qu&#8217;on ait.</p>
<p>JS n&#8217;est bon à rien, et en rien. Il est mal foutu, c&#8217;est un brouillon qu&#8217;on se traine.</p>
<p>Certes, des gens brillant font des choses brillantes avec, performantes, utiles, fantastique.</p>
<p>Mais c&#8217;est MALGRE le language, pas GRACE au langage.</p>
<p>Tout autre langage ferait mieux. Malheureusement on a que celui là dans le navigateur.</p>
<p>Et comme on a que celui-là et que le Web est tout, on a investi des ressources incroyables dans le JS pour pallier sa nature déficiente. Si tu investis la moitié de ces ressources dans n&#8217;importe quel techo, tu aurais un truc extra-ordinnaire :</p>
<ul>
<li>tu prends la V8 de google et tu l&#8217;applique à un autre langage ? Boom ! Perfs de ouf. 10X celles du JS actuel.</li>
<li>tu mets les commités d&#8217;amélioration ES6 et ES7 sur un autre langage ? Boom. Features de ouf (JS n&#8217;a pas encore rattrapé son retard malgré ça).</li>
<li>tu transferts la communauté des devs web sur un autre langage ? Boom, doc et libs incroyable. (Quand on voit le nombre de personnes là dessus, on se dit que ce potentiel est tellement gaché, tant les tutos JS sont souvent merdiques)</li>
</ul>
<p>Toutes les qualités de l&#8217;environnement JS sont uniquement liées au portail captif qu&#8217;est le navigateur, qui a forcé tout ce petit monde à payer la taxe JS. Rien à avoir avec le langage, qui est mal foutu, un verru dans le monde de la programmation.</p>
]]></content:encoded>
	</item>
	<item>
		<title>By: Toto</title>
		<link>http://sametmax.com/la-mort-du-tuto-angular/#comment-162181</link>
		<dc:creator><![CDATA[Toto]]></dc:creator>
		<pubDate>Tue, 16 Jun 2015 18:43:57 +0000</pubDate>
		<guid isPermaLink="false">http://sametmax.com/?p=16389#comment-162181</guid>
		<description><![CDATA[Le langage de base d&#039;un ordinateur est l&#039;assembleur (basiquement une représentation &quot;lisible&quot; par les humains des instructions machine). Aujourd&#039;hui nous ne développons plus en assembleur (sauf pour de rares exceptions très spécifiques) parce que c&#039;est vite complexe et qu&#039;il existe des compilateurs qui écrivent de l&#039;assembleur bien plus efficace que nous à partir d&#039;un langage plus proche de nos modes de pensée (C, C++, Python, etc).

Si le Javascript était l&#039;assembleur du navigateur web, alors nous n&#039;aurions plus à y toucher (sauf encore pour de rares exceptions très spécifiques) puisque nous disposerions d&#039;un langage de haut niveau capable de compiler du Javascript. C&#039;est le rôle du compilateur de connaître les subtilités et faiblesses du langage et les variantes selon les plateformes, et non le rôle du développeur. Ainsi, nous pourrions utiliser n&#039;importe quel langage de haut niveau que l&#039;on souhaite pour peu qu&#039;il existe un compilateur adapté.

Un bon informaticien est un informaticien fainéant qui automatise les tâches rébarbatives. Ecrire du javascript compatible, propre et performant est une perte de temps: écrivons un programme qui le fait pour nous et concentrons nous sur les vraies problématiques.

Ce temps viendra, nous sommes encore à la préhistoire des technos web.
]]></description>
		<content:encoded><![CDATA[<p>Le langage de base d&#8217;un ordinateur est l&#8217;assembleur (basiquement une représentation &#8220;lisible&#8221; par les humains des instructions machine). Aujourd&#8217;hui nous ne développons plus en assembleur (sauf pour de rares exceptions très spécifiques) parce que c&#8217;est vite complexe et qu&#8217;il existe des compilateurs qui écrivent de l&#8217;assembleur bien plus efficace que nous à partir d&#8217;un langage plus proche de nos modes de pensée (C, C++, Python, etc).</p>
<p>Si le Javascript était l&#8217;assembleur du navigateur web, alors nous n&#8217;aurions plus à y toucher (sauf encore pour de rares exceptions très spécifiques) puisque nous disposerions d&#8217;un langage de haut niveau capable de compiler du Javascript. C&#8217;est le rôle du compilateur de connaître les subtilités et faiblesses du langage et les variantes selon les plateformes, et non le rôle du développeur. Ainsi, nous pourrions utiliser n&#8217;importe quel langage de haut niveau que l&#8217;on souhaite pour peu qu&#8217;il existe un compilateur adapté.</p>
<p>Un bon informaticien est un informaticien fainéant qui automatise les tâches rébarbatives. Ecrire du javascript compatible, propre et performant est une perte de temps: écrivons un programme qui le fait pour nous et concentrons nous sur les vraies problématiques.</p>
<p>Ce temps viendra, nous sommes encore à la préhistoire des technos web.</p>
]]></content:encoded>
	</item>
</channel>
</rss>
